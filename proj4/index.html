<html>
  <head>
    <link rel="stylesheet" href="./style.css" />
  </head>

  <body>
    <h1>Project 4: Cloth Simulator</h1>
    by Kelly Hu and Sofia Howard-Jimenez
    <br />
    <a href="https://hukellyy.github.io/proj-webpage-kelbee/proj3-1/index.html"
      >https://hukellyy.github.io/proj-webpage-kelbee/proj3-1/index.html</a
    >

    -- head to the link for working GIFs! :]
    <br /><br />
    <hr />
    <br />
    <h2>Overview</h2>
    <p>
      In Project 4, we successfully implemented a cloth simulator. .... [explain challenges 
      and troubleshooting since we lost points for that in proj 3]
    </p>
    <h2>Part 1: Masses and springs</h2>
    <h3>
      Take some screenshots of scene/pinned2.json from a viewing angle where you can 
      clearly see the cloth wireframe to show the structure of your point masses and 
      springs.
    </h3>
    <p>
      Lorem ipsum
    </p>
    <div id="row">
      <div>
        <img src="img/all-constraints.png" width="98%" id="figure" />
        <figcaption>Our cloth wireframe</figcaption>
      </div>
    </div>
    <h3>
      Show us what the wireframe looks like (1) without any shearing constraints, 
      (2) with only shearing constraints, and (3) with all constraints.
    </h3>
    <p>
      Lorem ipsum
    </p>
    <div id="row">
      <div>
        <img src="img/struct-bend.png" width="98%" id="figure" />
        <figcaption>With STRUCTURAL and BENDING constraints</figcaption>
      </div>

      <div>
        <img src="img/shearing.png" width="98%" id="figure" />
        <figcaption>With SHEARING constraints</figcaption>
      </div>

      <div>
        <img src="img/wirefrmae.png" width="98%" id="figure" />
        <figcaption>With ALL constraints</figcaption>
      </div>
    </div>

    <br />
    <br />

    <h2>Part 2: Simulation via numerical integration</h2>
    <h3>
      Experiment with some the parameters in the simulation. To do so, pause the simulation 
      at the start with P, modify the values of interest, and then resume by pressing P again. 
      You can also restart the simulation at any time from the cloth's starting position by 
      pressing R.
    </h3>
    <h3>
      Describe the effects of changing the spring constant ks; how does the cloth behave from 
      start to rest with a very low ks? A high ks?
    </h3>
    <p>
      We can think of ks (the spring constant) as determining how flexible versus stagnant our spring is. With a 
      smaller ks, we have a bouncier, more flexible spring. With a larger ks, we have a much less flexible spring. 
      When I played around with differnt ks values, setting it to a lower number like 35 made the cloth super 
      seemingly stretchy and flowy, while setting to a higher number made it a lot more rigid. The magnitude of ks 
      definitely makes the cloth seem like it's made of varying strengthes/durabilities of material. In terms of visual 
      differences, we could discern these details through noticing smaller folds and wrinkles in the cloths with 
      smaller ks values (see ks = 35), and singular large folds in the higher values (see ks = 10000).  
    </p>

    <br />
    
    <div id="row">
      <div>
        <img src="img/ks_35.gif" width="98%" id="figure" />
        <figcaption>[GIF] Setting ks = 35</figcaption>
      </div>

      <div>
        <img src="img/ks_500.gif" width="98%" id="figure" />
        <figcaption>[GIF] Setting ks = 500</figcaption>
      </div>

      <div>
        <img src="img/ks_10000.gif" width="98%" id="figure" />
        <figcaption>[GIF] Setting ks = 10000</figcaption>
      </div>
    </div>

    <br />

    <div id="row">
      <div>
        <img src="img/ks_35.png" width="98%" id="figure" />
        <figcaption>[Resting State] Setting ks = 35</figcaption>
      </div>

      <div>
        <img src="img/ks_500.png" width="98%" id="figure" />
        <figcaption>[Resting State] Setting ks = 500</figcaption>
      </div>

      <div>
        <img src="img/ks_10000.png" width="98%" id="figure" />
        <figcaption>[Resting State] Setting ks = 10000</figcaption>
      </div>
    </div>

    <br />
    <h3>
      What about for density?
    </h3>
    <p>
      When we think of density, lower values make the cloth look/feel lighter while higher values make it feel 
      a lot more heavy (can also be obviously described as "dense"). Specifically, we tried setting the density to 1000, and the fabric 
      draped down in a way where it seemed to experience more gravity or pulling, almost like it was heavier. 
      When we set it to a low value of 2, there were a significant difference in the size of the folds and 
      wrinkles in the cloth.
    </p>

    <br />

    <div id="row">
      <div>
        <img src="img/den_2.gif" width="98%" id="figure" />
        <figcaption>[GIF] Setting density = 2</figcaption>
      </div>

      <div>
        <img src="img/den_100.gif" width="98%" id="figure" />
        <figcaption>[GIF] Setting density = 100</figcaption>
      </div>

      <div>
        <img src="img/den_1000.gif" width="98%" id="figure" />
        <figcaption>[GIF] Setting density = 1000</figcaption>
      </div>
    </div>

    <br />

    <div id="row">
      <div>
        <img src="img/den_2.png" width="98%" id="figure" />
        <figcaption>[Resting State] Setting density = 2</figcaption>
      </div>

      <div>
        <img src="img/den_100.png" width="98%" id="figure" />
        <figcaption>[Resting State] Setting density = 100</figcaption>
      </div>

      <div>
        <img src="img/den_1000.png" width="98%" id="figure" />
        <figcaption>[Resting State] Setting density = 1000</figcaption>
      </div>
    </div>
    <br />

    <h3>
      What about for damping?
    </h3>
    <p>
      For damping, we can think of it as loss in energy or the decreasing of amplitude of spring oscillations in 
      our system. Setting dampling values lower means that there will be less energy loss over a period of time, 
      and the oscillations will fade slower, while setting damping values higher means that there will be more 
      energy lost over a period of time, and the oscillations will fade faster. To illustrate this quantitatively, 
      when we tried making the damping param equal to 1, the cloth fell down very slowly and only ahd one 'swing'
      into its resting state. I assume this is due to the fact that the cloth is losing all its energy on its way 
      down, making it come to a stop once it is fully draped. On the other hand, when we set the damping param equal
      to 0, the cloth bounced around uncontrollably, swinging back and forth very quickly without stopping. This is due to 
      the fact that 0 damping essentially corresponds to 0 loss in energy, so the cloth does not ever go into a resting state. 
    </p>
    <br />

    <div id="row">
      <div>
        <img src="img/damp_0.gif" width="98%" id="figure" />
        <figcaption>[GIF] Setting damping = 0</figcaption>
      </div>

      <div>
        <img src="img/damp_0.25.gif" width="98%" id="figure" />
        <figcaption>[GIF] Setting damping = 0.25</figcaption>
      </div>

      <div>
        <img src="img/damp_1.gif" width="98%" id="figure" />
        <figcaption>[GIF] Setting damping = 1</figcaption>
      </div>
    </div>

    <br />
    
    <h3>
      For each of the above, observe any noticeable differences in the cloth compared to the
       default parameters and show us some screenshots of those interesting differences and describe when they occur.
    </h3>


    <div id="row">
      <div>
        <img src="img/den_15_default.gif" width="98%" id="figure" />
        <figcaption>[GIF] DEFAULT SETTINGS</figcaption>
      </div>

      <div>
        <img src="img/den_15_default.png" width="98%" id="figure" />
        <figcaption>[IMG] DEFAULT SETTINGS</figcaption>
      </div>
    </div>

    <p>
      TO DO HERE AHH SORRY SOFIA
    </p>

    <h3>
      Show us a screenshot of your shaded cloth from scene/pinned4.json in its final resting state!
      If you choose to use different parameters than the default ones, please list them.
    </h3>

    <div>
      <img src="img/pinned_4_rest.png" width="98%" id="figure" />
      <figcaption>resting state of pinned4 with DEFAULT SETTINGS</figcaption>
    </div>    

    <br /><br />

    <h2>Part 3: Handling collisions with other objects</h2>
    <h3>Walk through both implementations of the direct lighting function.</h3>
    <p>
      In Part 3, we implement direct lighting, which kickstarts our process of
      modelling shading that is more realistic. At a high level, we estimate
      direct illumination by projecting rays from the surface intersection
      point. Illumination only occurs if and only if the ray intersects with a
      light source.
    </p>
    <p>
      We start by implementing the diffuse BSDF and zero bounce illumination.
      Both of these functions are responsible for estimating the contribution of
      direct lighting at a given intersection point. The difference between the
      two is that the first function, estimate_direct_lighting_hemisphere, uses
      uniform sampling in a hemisphere around the intersection point to estimate
      direct lighting, while the second function,
      estimate_direct_lighting_importance, uses importance sampling.
    </p>
    <p>
      The estimate_direct_lighting_hemisphere function first constructs a
      coordinate system with the hit point normal aligned with the Z-axis (0, 0,
      1). It then generates a random direction in the hemisphere above the hit
      point using a hemisphere sampler. For each sample, it transforms the
      sample into world space, generates a ray, and checks if the ray intersects
      any object in the scene. If it does not intersect any objects, it
      calculates the contribution of the light by multiplying the light's
      emission, the BSDF of the surface at the intersection point, and the
      cosine of the angle between the sampled direction and the surface normal.
      Finally, it averages the contributions over all the samples and returns
      the result.
    </p>
    <p>
      The estimate_direct_lighting_importance function also constructs a
      coordinate system with the hit point normal aligned with the Z-axis. It
      then loops over all the lights in the scene and for each light, it
      generates a random direction using importance sampling according to the
      probability density function (pdf) of the light. It generates a ray,
      checks for intersection with objects, and calculates the light's
      contribution using the same method as in the
      estimate_direct_lighting_hemisphere function. Finally, it averages the
      contributions over all the lights and samples and returns the result.
    </p>
    <br />
    <h3>
      Show some images rendered with both implementations of the direct lighting
      function. Focus on one particular scene with at least one area light and
      compare the noise levels in soft shadows when rendering with 1, 4, 16, and
      64 light rays (the -l flag) and with 1 sample per pixel (the -s flag)
      using light sampling, not uniform hemisphere sampling.
    </h3>
    <br />
    <div id="row">
      <div>
        <img src="img/bunny_1_1.png" width="98%" id="figure" />
        <figcaption>1 light ray</figcaption>
      </div>
      <div>
        <img src="img/bunny_4_1.png" width="98%" id="figure" />
        <figcaption>4 light rays</figcaption>
      </div>
    </div>
    <br />
    <br />
    <div id="row">
      <div>
        <img src="img/bunny_16_1.png" width="98%" id="figure" />
        <figcaption>16 light rays</figcaption>
      </div>
      <div>
        <img src="img/bunny_64_1.png" width="98%" id="figure" />
        <figcaption>64 light rays</figcaption>
      </div>
    </div>
    <p>
      Looking at the images rendered above, it can be seen that there is a
      drastic amount of noise that gets reduced as we add more light rays. With
      1 ray, the shadowed area of the bunny is a lot noisier, and reaches a
      pretty large distance into the box. But as we increase rays, the shadow
      begins to get softer and concentrate more around the bunny than into the
      box. The increased number of rays evidently generates more accuracy in the
      estimation of reflected light (less variance). The shadows in the corners
      of the wall also soften as the number of rays increase.
    </p>
    <h3>
      Compare the results between uniform hemisphere sampling and lighting
      sampling in a one-paragraph analysis.
    </h3>
    <p>
      The results from uniform sampling are much noiser in general than the
      results from importance sampling the lights because they sample uniformly
      around the intersection point rather than from the light sources in the
      scene themselves. The results from uniform sampling also are unable to
      render images that only have point lights, whereas the lighting sampling
      algorithm saves time on point lights by only sampling once. The results
      for uniform hemisphere sampling and lighting sampling do converge to the
      same image as the number of samples increases since they are built from
      the same mesh, but for lower sample-per-pixel rates the lighting sampling
      greatly out performs the uniform hemisphere sampling because the uniform
      sampling leaves black dots throughut the image since each pixel is
      sampling uniformly, whereas with lighting sampling each pixel is sampling
      from the same set of lights, so noise is more concentrated in areas of
      shadow.
    </p>
    <br />
    <br />

    <h2>Part 4: Handling self-collisions</h2>
    <h3>Walk through your implementation of the indirect lighting function.</h3>
    <p>
      In order to implement the indirect lighting function, we had to sum up the
      possible paths that bounces of light could take after the zeroeth or first
      bounces of light. First, we had to implement <code>sample_f</code>, which
      represents a diffuse material that reflects incoming light equally across
      all directions on the hemisphere. This function samples the incoming ray,
      and we implemented it by calling <code>get_sample</code> on the
      <code>sampler</code> variable, which samples an incoming direction and
      writes that into <code>wi</code>.
    </p>
    <p>
      Once we implemented sample_f, we now are able to implement
      <code>at_least_one_bounce_radiance</code>, which recursively calls
      <code>one_bounce_radiance</code> for each bounce of light and stops using
      a Russian Roulette algorithm that terminates with probability 0.4. Within
      <code>one_bounce_radiance</code>, if the algorithm is not terminated by
      Russian Roulette and if the depth of the ray is less than or equal to 1,
      then we will call <code>sample_f</code> based on the BSDF at the current
      <code>Intersection</code>, trace a ray in that direction, then recursively
      call <code>at_least_one_bounce_radiance</code>
      by adding the recursive output to the current output.
    </p>
    <p>
      After <code>at_least_one_bounce_radiance</code> was updated, we also had
      to update <code>est_radiance_global_illumination</code> so that it returns
      <code
        >L_out = zero_bounce_radiance(r, isect) +
        at_least_one_bounce_radiance(r, isect);</code
      >, which combines the direct and indirect lighting estimates.
    </p>
    <h3>
      Show some images rendered with global (direct and indirect) illumination.
      Use 1024 samples per pixel.
    </h3>
    <div id="row">
      <div>
        <img src="img/part4_banana.png" width="98%" id="figure" />
      </div>
      <div>
        <img src="img/part4_bunny.png" width="98%" id="figure" />
      </div>
    </div>
    <h3>
      Pick one scene and compare rendered views first with only direct
      illumination, then only indirect illumination. Use 1024 samples per pixel.
      (You will have to edit PathTracer::at_least_one_bounce_radiance(...) in
      your code to generate these views.)
    </h3>
    <div id="row">
      <div>
        <img src="img/direct_light.png" width="98%" id="figure" />
        <figcaption>direct illumination </figcaption>
      </div>
      <div>
        <img src="img/indirect_light.png" width="98%" id="figure" />
        <figcaption>indirect illumination </figcaption>
      </div>
    </div>
    <br />

    <h3>
      For CBbunny.dae, compare rendered views with max_ray_depth set to 0, 1, 2,
      3, and 100 (the -m flag). Use 1024 samples per pixel.
    </h3>
    <div id="row">
      <div>
        <img src="img/max_ray_0.png" width="98%" id="figure" />
        <figcaption>max_ray_depth = 0</figcaption>
      </div>
      <div>
        <img src="img/max_ray_1.png" width="98%" id="figure" />
        <figcaption>max_ray_depth = 1</figcaption>
      </div>
    </div>
    <div id="row">
      <div>
        <img src="img/max_ray_2.png" width="98%" id="figure" />
        <figcaption>max_ray_depth = 2</figcaption>
      </div>
      <div>
        <img src="img/max_ray_3.png" width="98%" id="figure" />
        <figcaption>max_ray_depth = 3</figcaption>
      </div>
      <div>
        <img src="img/max_ray_100.png" width="98%" id="figure" />
        <figcaption>max_ray_depth = 100</figcaption>
      </div>
    </div>
    <br />

    <h3>
      Pick one scene and compare rendered views with various sample-per-pixel
      rates, including at least 1, 2, 4, 8, 16, 64, and 1024. Use 4 light rays.
    </h3>
    <div id="row">
      <div>
        <img src="img/sphere_1.png" width="98%" id="figure" />
        <figcaption>sample-per-pixel = 1</figcaption>
      </div>
      <div>
        <img src="img/sphere_2.png" width="98%" id="figure" />
        <figcaption>sample per pixel = 2</figcaption>
      </div>
    </div>
    <div id="row">
      <div>
        <img src="img/sphere_3.png" width="98%" id="figure" />
        <figcaption>sample per pixel = 3</figcaption>
      </div>

      <div>
        <img src="img/sphere_4.png" width="98%" id="figure" />
        <figcaption>sample per pixel = 4</figcaption>
      </div>
    </div>
    <div id="row">
      <div>
        <img src="img/sphere_8.png" width="98%" id="figure" />
        <figcaption>sample per pixel = 8</figcaption>
      </div>
      <div>
        <img src="img/sphere_16.png" width="98%" id="figure" />
        <figcaption>sample per pixel = 16</figcaption>
      </div>
    </div>
    <div id="row">
      <div>
        <img src="img/sphere_64.png" width="98%" id="figure" />
        <figcaption>sample per pixel = 64</figcaption>
      </div>
      <div>
        <img src="img/sphere_1024.png" width="98%" id="figure" />
        <figcaption>sample per pixel = 1024</figcaption>
      </div>
    </div>

    <br />
    <br />

    <h2>Part 5: Shaders (longest, start early!)</h2>
    <h3>
      Explain adaptive sampling. Walk through your implementation of the
      adaptive sampling.
    </h3>
    <p>
      In part 5 of the project, we added adaptive sampling to reduce the noise
      in the image, which concentrates the samples in more difficult parts of
      the image as opposed to using a fixed number of samples per pixel.
    </p>
    <p>
      We implemented adaptive sampling by updating
      <code>raytrace_pixel</code> to detect whether the pixel has converged as
      we trace the samples thrrough that pixel. In order to do this, we solve
      for the pixels convergence
      <code>double I = 1.96 * (standard_deviation / sqrt(sample_number))</code>
      and check if <code>I <= (maxTolerance * mean)</code>, for which we would
      say the pixel has converged and we stop tracing rays for this pixel. we
      calculated the standard deviation by solving for the variance using the
      sum of the illuminance and sum of the illuminance squared for the pixel
      and taking the square root of said variance.
    </p>
    <h3>
      Pick two scenes and render them with at least 2048 samples per pixel. Show
      a good sampling rate image with clearly visible differences in sampling
      rate over various regions and pixels. Include both your sample rate image,
      which shows your how your adaptive sampling changes depending on which
      part of the image you are rendering, and your noise-free rendered result.
      Use 1 sample per light and at least 5 for max ray depth.
    </h3>
    <div id="row">
      <div>
        <img src="img/part5_bunny.png" width="98%" id="figure" />
      </div>
      <div>
        <img src="img/part5_sphere.png" width="98%" id="figure" />
      </div>
    </div>
    <div id="row">
      <div>
        <img src="img/part5_bunny_sr.png" width="98%" id="figure" />
        <figcaption>sample rate image for the bunny</figcaption>
      </div>
      <div>
        <img src="img/part5_sphere_sr.png" width="98%" id="figure" />
        <figcaption>sample rate image for the spheres</figcaption>
      </div>
      </div>
    </div>

    <br /><br />
    <hr />
    <br />
    <p>Link to Website:</p>
    <a href="https://hukellyy.github.io/proj-webpage-kelbee/proj3-1/index.html"
      >https://hukellyy.github.io/proj-webpage-kelbee/proj3-1/index.html</a
    >
  </body>
</html>
