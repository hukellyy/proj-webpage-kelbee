<html>
  <head>
    <link rel="stylesheet" href="./style.css" />
  </head>

  <body>
    <h1>Project 2: Mesh Editor</h1>
    by Kelly Hu and Sofia Howard Jimenez
    <br />
    <a href="https://hukellyy.github.io/proj-webpage-kelbee/proj2/index.html">https://hukellyy.github.io/proj-webpage-kelbee/proj2/index.html</a>
    <br /><br />
    <hr />
    <br />
    <h2>Overview</h2>
    <p>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod 
		tempor incididunt ut labore et dolore magna aliqua. 
    </p>
    <h1>Section I: Bezier Curves and Surfaces</h1>

    <h2>Part 1</h2>
    <p>
		De Casteljau's algorithm is a technique that allows us to evaluate Bezier curves. 
    Bezier curves by definition have two endpoints and a number of control points on 
    the curve. For de Casteljau, curves with less control points are ideal, since more 
    points (and a higher-degree curve) are more difficult to interpolate.
	  </p>
    <p>
    First, the algorithm does linear interpolation between pairs of adjacent points 
    and lays down a new control point on each edge. Since the algorithm is recursive, 
    this step is repeated, and a new control point is placed on each new edge until 
    there is only one point left. 
    </p>
    <p>
    For part 1, we implemented the function <code>evaluateStep()</code>, which inputs the most recent set of control points 
    and finds the next level. In <code>evaluateStep()</code>, the algorithm iterates over the control 
    points (<code>points</code>), checking if the size of the levels evaluated are equal to the number of control points, 
    and computes the weighted average of its neighbouring points, using the parameter 't' and the formula 
    for linear interpolation (lerp) defined by de Casteljau:

    We store intermediate points found in a 2D vector called <code>intermediate</code> 
    and return it as the output of the function. In this way, the most recent level of control points 
    is stored in <code>intermediate</code> and updated each time the function is called. 
    </p>
    <br />
    <div id="row">
      <div>
        <img src="img/part1-a.gif" width="98%" id="figure" />
        <figcaption>Stepping through a Bezier curve with 6 points</figcaption>
      </div>
      <div>
        <img src="img/part1-b.gif" width="98%" id="figure" />
        <figcaption>A slightly different curve & modifying parameter t</figcaption>
      </div>
      </div>
    <br />
    <br />

    <h2>Part 2</h2>
    <p>
      Building off the concept of Bezier curves, we will now extend the idea to 
      add another dimension. Bezier surfaces are also defined
      by a set of control points, where a Bezier surface patch consists of 4x4 
      control points. To visualize or implement this, we can imagine having 4 
      curves in the u-direction, or 4x1 control points in the u-direction. Then,
      we can define 4 more control points in the v-direction as "moving curves", 
      which are essentially sweeping out the 2D surface / connecting the 4 curves 
      made in the u direction. 
	  </p>
    <p>
      To implement our Bezier surfaces, we extended off our code from Part 1. 
      To evaluate a Bezier patch for a position <code>(u, v)</code> on the Bezier surface, we can use 
      the 1D de Casteljau algorithm. First, we started by finding 4 u-points in one direction, 
      specifically for each curve in the u-direction. After, we use these points to 
      find the control points in the v-direction for the moving curve. 
    </p>
	<div id="row">
		<div>
		  <img src="img/part2.png" width="98%" id="figure" />
		  <figcaption>bez/teapot.bez</figcaption>
		</div>
		<div>
		  <img src="img/part2-nowire.png" width="98%" id="figure" />
		  <figcaption>bez/teapot.bez with wireframe off</figcaption>
		</div>
	  </div>
    <br /><br>

	<h1>Section II: Sampling</h1>

    <h2>Part 3</h2>
	<p>
		In Part 3, we were tasked with implementing area-weighted vertex normals to use for Phong shading. This allows us 
    to better shade smooth surfaces as it produces the "smoothing" effect by performing linear interpolations on the vertex normals as 
    opposed to face normals.
	</p>
  <p>
		In order to compute an area-weighted normal for a given vertex, we first iterated through the faces incident to the vertex 
    and found the face normal multiplied by the face's area for each face. We found the area from the Vertex positions for that face. We then
    added the weighted face normal to the norm sum (which we initilized to be 0). After iterating through
    all the faces, we then averaged the norm sum by dividing by the number of faces and returned the normalized norm sum.
	</p>
  <div id="row">
		<div>
		  <img src="img/part3-nophong.png" width="98%" id="figure" />
		  <figcaption>bez/teapot.bez without smooth shading</figcaption>
		</div>
		<div>
		  <img src="img/part3-phong.png" width="98%" id="figure" />
		  <figcaption>bez/teapot.bez with smooth shading</figcaption>
		</div>  
	</div>
  <br />
  <br />
  <div id="row">
    <div>
      <img src="img/part3-close.png" width="98%" id="figure" />
      <figcaption>bez/teapot.bez without smooth shading</figcaption>
    </div>
    <div>
      <img src="img/part3-phong-close.png" width="98%" id="figure" />
      <figcaption>bez/teapot.bez with smooth shading</figcaption>
    </div>
  </div>
    
  <p></p>
  <br />
  <br />

    <h2>Part 4</h2>
	<p>
		To implement the edge flip operation, which essentially performs the function of 
    flipping an edge, we started by outlining our approach as needing to reassign a 
    bunch of pointers for halfedges, vertices, edges, and faces, to a new set of correct 
    halfedges, vertices, edges, and faces. 

    We then proceeded to jot down and initialize all the pointers necessary, using a diagram to keep track 
    of all the halfedges, faces, vertices, face's edges, and corresponding halfedges that 
    we need to update, illustrating what it should look like before and after the flip. Then, 
    we started to reassign everything carefully, according to the diagrams drawn. This was 
    definitely a very tedious process, and we had to go back and redo some reassignments due 
    to typos or wrong pointers, but eventually we were able to reassign everything mostly correctly. 
    To debug, we ran through the code multiple times to figure out if we missed a pointer or 
    assigned one incorrectly by mistake. After a few iterations of this, we ended up with a working 
    edge flip! Finally, we also identified an edge case where we checked if the edge is a boundary, in which we 
    return right away. 

    Thankfully, we didn't need to endure too much debugging for this part, but Part 5 was definitely 
    an interesting experience...
	</p>
    <div id="row">
		<div>
		  <img src="img/before-part4.png" width="98%" id="figure" />
		  <figcaption>Teapot before edge flipping</figcaption>
		</div>
		<div>
		  <img src="img/after-part4.png" width="98%" id="figure" />
		  <figcaption>Teapot after flipping a bunch of edges</figcaption>
		</div>
	  </div>
    <br />
      A screenshot of svg/basic/test7.svg with default viewing parameters and
      sample rate 1
    </figcaption>

    <br />
    <br />

    <h2>Part 5</h2>
    <p>
		After implementing the edge flip, we then implemented the edge split operation. 
    The first step in the implementation process for this operation was drawing a diagram
    with every edge, vertex, face, and half edge labled before and after the edge split operation.
    Similarly to edge flip, it was then a matter of updating pointers and creating new mesh 
    elements if needed.
	</p>
  <div>
    <img src="img/placeholder.png" width="98%" id="figure" />
    <figcaption>diagram</figcaption>
  </div>
  <p>
		This problem was also very tedious to debug! We checked our diagram and code many many times.
    TODO: add more about debugging LOL :P
	</p>
    <br /><br />
    <div id="row">
      <div>
        <img src="img/placeholder.png" width="98%" id="figure" />
        <figcaption>bez/teapot.bez</figcaption>
      </div>
      <div>
        <img src="img/placeholder.png" width="98%" id="figure" />
        <figcaption>bez/teapot.bez with wireframe off</figcaption>
      </div>
      </div>
	<p>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod 
		tempor incididunt ut labore et dolore magna aliqua. 
	</p>

    <br />
    <br />

    <h2>Part 6</h2>
    <p>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod 
		tempor incididunt ut labore et dolore magna aliqua. 
	</p>

    <br /><br />
    <div id="row">
      <div>
        <img src="img/placeholder.png" width="98%" id="figure" />
        <figcaption>bez/teapot.bez</figcaption>
      </div>
      <div>
        <img src="img/placeholder.png" width="98%" id="figure" />
        <figcaption>bez/teapot.bez with wireframe off</figcaption>
      </div>
      </div>
    <br /><br />
    <hr />
    <br />
    <p>Link to Website:</p>
    <a href="https://hukellyy.github.io/proj-webpage-kelbee/proj2/index.html">https://hukellyy.github.io/proj-webpage-kelbee/proj2/index.html</a>
  </body>
</html>
